import heapq #Import heapq for priority queue operations (used in A* algorithm).

#Goal state
goal = ['W', 'W', 'W', ' ', 'B', 'B', 'B']

#Function to calculate the number of misplaced tiles
#This heuristic counts how many tiles are in the wrong position, excluding the empty space.
def misplacedtiles(state, goal):
    return sum(1 for i in range(len(state)) if state[i] != goal[i] and state[i] != ' ')

#Function to calculate the Manhattan distance
#In this case, it's adapted for the linear puzzle. This sums the distances of each tile from its goal position.
def manhattan(state, goal):
    distance = 0
    for i, tile in enumerate(state):
        if tile != ' ':
            goalpos = goal.index(tile)
            currentrow, currentcol = divmod(i, len(state))
            goalrow, goalcol = divmod(goalpos, len(state))
            distance += abs(currentrow - goalrow) + abs(currentcol - goalcol) #Simply compute the difference in positions for this linear puzzle
    return distance

#Combined heuristic function
#This combines the two heuristics: misplaced tiles and Manhattan distance
def combined(state):
    return misplacedtiles(state, goal) + manhattan(state, goal)

#Function to generate neighbouring states
#Neighbours are generated by moving the empty space left or right, or hopping over adjacent tiles
def neighbours(state):
    neighbourlist = []
    emptypos = state.index(' ')
    
    #Possible moves (left, right)
    moves = [-1, 1]
    for move in moves:
        newpos = emptypos + move
        #Ensure the new position is valid and adjacent
        if 0 <= newpos < len(state) and abs(newpos - emptypos) == 1:
            newstate = state[:]
            #Swap the empty space with the tile next to it
            newstate[emptypos], newstate[newpos] = newstate[newpos], newstate[emptypos]
            neighbourlist.append((newstate, 1))  # Cost for adjacent move

    # Possible hops
    hops = [-2, 2]
    for hop in hops:
        newpos = emptypos + hop
        middlepos = emptypos + (hop // 2) #Find the tile we're hopping over
        #Ensure the new and middle positions are valid and that we're hopping over a tile
        if 0 <= newpos < len(state) and 0 <= middlepos < len(state) and state[middlepos] != ' ':
            newstate = state[:]
            #Swap the empty space with the tile we're hopping over
            newstate[emptypos], newstate[newpos] = newstate[newpos], newstate[emptypos]
            neighbourlist.append((newstate, abs(hop // 2)))  # Cost for hopping

    return neighbourlist

#A* algorithm implementation
#This function finds the solution to the sliding-tile puzzle using A* search
def astar(start, goal):
    openlist = []
    #Push the initial state with f=0, g=0 (no moves made yet), and an empty path
    heapq.heappush(openlist, (0, start, [], 0))  #(f, state, path, g)
    visited = set()

    #While there are still states to explore
    while openlist:
        f, current, path, g = heapq.heappop(openlist) #Get the state with the lowest f

        #If the current state matches the goal, return the solution path and the cost (number of moves)
        if current == goal:
            return path + [current], g  # Return the solution path and the cost

        visited.add(tuple(current))  # Mark the state as visited

        #Explore neighbours
        for neighbour, movecost in neighbours(current):
            if tuple(neighbour) not in visited:
                h = combined(neighbour) #Calculate heuristic for the neighbour
                newg = g + movecost #Update the cost of reaching this neighbour
                f = newg + h #Total cost (f = g + h)
                heapq.heappush(openlist, (f, neighbour, path + [current], newg)) #Add the neighbour to the open list

    return None, -1  # No solution found

# Function to print the board in a readable format
def printboard(board):
    print('+----------------------+')
    print('| ' + ' | '.join(board) + ' |')
    print('+----------------------+')
    print()

# Example starting state for the puzzle (3 black tiles, empty space, 3 white tiles)
start = ['B', 'B', 'B', ' ', 'W', 'W', 'W']

#Print the initial configuration
print("Initial configuration:")
printboard(start)

#Find the solution using A* algorithm
solution, moves = astar(start, goal)

#Print the result
if solution:
    print(f"Solution found in {moves} moves:")
    for state in solution:
        printboard(state) #Display each step in the solution
else:
    print("No solution found.") #In case if the puzzle solution cannot be solved
